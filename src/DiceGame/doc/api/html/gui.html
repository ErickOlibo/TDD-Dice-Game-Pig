<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gui API documentation</title>
<meta name="description" content="This module display info and interacts with the user." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gui</code></h1>
</header>
<section id="section-intro">
<p>This module display info and interacts with the user.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module display info and interacts with the user.&#34;&#34;&#34;
import os
from helpers import DIE_HEIGHT, DICE_FACES, DIE_SEP
import time


class GUI:
    &#34;&#34;&#34;This class controls how the data is display to user.&#34;&#34;&#34;

    def clear_terminal(self):
        &#34;&#34;&#34;
        Clear the terminal window.

        Description:
            This method clears the contents of the terminal using the &#39;clear&#39;
            command from the os module. It is used to provide a clean slate for
            displaying new information to the user.

        &#34;&#34;&#34;
        os.system(&#39;clear&#39;)

    def display_info(self, text: str, title: str, width=40):
        &#34;&#34;&#34;
        Display information to the user.

        Description:
            This method displays the provided text and title to the user,
            formatted with a header created by the _set_menu_header() method.
            The width of the header can be customized using the width argument.
            The text is printed to the console using the print() function.

        Args:
            text (str): The text to display to the user.
            title (str): The title of the information being displayed.
            width (int, optional): The width of the header. Default is 40.
        &#34;&#34;&#34;
        header = self._set_menu_header(title, width)
        info = &#34;&#34;.join([header, text])
        print(info)

    def get_simple_answer_from_user(self, ask: str,
                                    title: str, width=40) -&gt; str:
        &#34;&#34;&#34;
        Get a simple user input.

        Description:
            This method displays a question to the user, along with a
            formatted title header created by the _set_menu_header() method.
            The user&#39;s response is read from the console using the input()
            function and returned as a string.

        Args:
            ask (str): The question to ask the user.
            title (str): The title of the input being requested.
            width (int, optional): The width of the header. Default is 40.

        Returns:
            str: The user&#39;s input as a string.
        &#34;&#34;&#34;
        header = self._set_menu_header(title, width)
        ask_input = &#34;\n&#34;.join([header, ask])
        return input(ask_input)

    def get_simple_answer_from_cpu(self, ask: str,
                                   title: str, width=40) -&gt; str:
        &#34;&#34;&#34;
        Get a simple response from the CPU.

        Description:
            This method displays a question to the CPU player, along with a
            formatted title header created by the _set_menu_header() method.
            The CPU&#39;s response is returned as a string.

        Args:
            ask (str): The question to ask the CPU.
            title (str): The title of the response being requested.
            width (int, optional): The width of the header. Default is 40.

        Returns:
            str: The CPU&#39;s response as a string.
        &#34;&#34;&#34;
        header = self._set_menu_header(title, width)
        ask_input = &#34;\n&#34;.join([header, ask])
        return ask_input

    def display_hand_results(self, numbers: list, points: int):
        &#34;&#34;&#34;
        Display the results of a dice roll.

        Description:
            This method takes a list of roll results and their point value,
            and formats them for display in a graphical representation of the
            dice faces. The resulting display is printed to the terminal.

        Args:
            numbers (list): A list of integers representing the face values
                            of the dice rolled.
            points (int): The total point value of the roll.

        &#34;&#34;&#34;
        faces = []
        for numb in numbers:
            faces.append(DICE_FACES[numb])

        faces_and_points = faces + [self._get_rolls_points(points)]

        faces_rows = []
        for idx in range(DIE_HEIGHT):
            row_cells = []
            for face in faces_and_points:
                row_cells.append(face[idx])
            row_line = DIE_SEP.join(row_cells)
            faces_rows.append(row_line)
        display = &#34;\n&#34;.join(faces_rows)
        print(display)

    def display_hand_results_split(self, numbers: list,
                                   points: int, split=4):
        &#34;&#34;&#34;
        Display the results of a hand of dice, split into chunks.

        Description:
        This method takes a list of integers representing the dice rolls,
        a total number of points, and an optional split parameter which
        determines how many dice should be displayed on each line.
        The method splits the dice rolls into chunks of size `split`,
        then displays the results of each chunk separately.
        The results of each chunk are displayed using the `DICE_FACES`
        constant, with a row of points displayed underneath the dice faces.

        Args:
        - numbers (list): A list of integers representing the dice rolls.
        - points (int): The total number of points for the hand.
        - split (int): An optional parameter which determines how many dice
          should be displayed on each line. Defaults to 4.
        &#34;&#34;&#34;
        chunk = [numbers[i:split+i] for i in range(0, len(numbers), split)]
        rows = []
        for int_list in chunk:
            faces = []
            for numb in int_list:
                faces.append(DICE_FACES[numb])
            if int_list == chunk[-1]:
                fap = faces + [self._get_rolls_points(points)]
            else:
                fap = faces + []
            faces_rows = []
            for idx in range(DIE_HEIGHT):
                row_cells = []
                for face in fap:
                    row_cells.append(face[idx])
                row_line = DIE_SEP.join(row_cells)
                faces_rows.append(row_line)
            display = &#34;\n&#34;.join(faces_rows)
            rows.append(display)
        lines = &#34;\n&#34;.join(rows)
        print(lines)

    def display_scoreboard(self, n1: str, s1: int,
                           n2: str, s2: int, hand: str):
        &#34;&#34;&#34;
        Display a scoreboard with two players&#39; names, scores, and current hand.

        Description:
        This method takes in the names and scores of two players,
        as well as the name of the player whose turn it is.
        It then generates a graphical scoreboard displaying the two players&#39;
        names and scores, along with an indication of whose turn it is.
        The scoreboard is printed to the console.

        Args:
            n1 (str): The name of player 1.
            s1 (int): The score of player 1.
            n2 (str): The name of player 2.
            s2 (int): The score of player 2.
            hand (str): The name of the player whose turn it is.

        &#34;&#34;&#34;
        c = [&#39;ğŸŸ©&#39;, &#39;ğŸŸ¥&#39;]
        if hand == n2:
            c.reverse()
        n1 = self._shrink_name(n1, 13)
        n2 = self._shrink_name(n2, 13)
        line1 = &#34;â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”&#34;
        line2 = f&#39;â”‚ {c[0]} â”‚ {n1:&lt;13}    {s1:&gt;3} â”‚ â”‚ &#39;
        line2 += f&#39;{c[1]} â”‚ {n2:&lt;13}    {s2:&gt;3}{&#34; â”‚&#34;}&#39;
        line3 = &#34;â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜&#34;
        scoreboard = &#34;\n&#34;.join([line1, line2, line3])
        print(scoreboard)

    def get_text_to_shown_menu(self, title: str,
                               question: str, options: list,
                               legend=[&#39;Option&#39;, &#39;Actions&#39;]) -&gt; str:
        &#34;&#34;&#34;
        Get user input from a shown menu.

        Description:
        This method displays a menu with the given title and options,
        and prompts the user with the given question to select an option.
        The method returns the user&#39;s input as a string.

        Args:
        - title (str): The title to display at the top of the menu.
        - question (str): The prompt to display to the user.
        - options (list): A list of strings representing the menu options.
        - legend (list): An optional list of strings that specify the column
          headings of the menu. Defaults to [&#39;Option&#39;, &#39;Actions&#39;].

        Returns:
        - input (str): The user&#39;s input as a string.
        &#34;&#34;&#34;
        menu = self._get_menu_layout(title, options, legend)
        menu += f&#34;\n{question}&#34;

        return menu

    def display_highscore(self, scores: list, size: int):
        &#34;&#34;&#34;
        Display high scores in a tabular format.

        Description:
        This method takes a list of high scores,
        displays them in a tabular format,
        with columns for rank, name, streak, and points.
        The table is sorted by the streak,
        and points columns in descending order.
        The number of scores displayedis determined by the `size` parameter.

        Args:
        - scores (list): A list of tuples containing the player name,
                         streak, and points.
        - size (int): The number of high scores to display.

        &#34;&#34;&#34;
        scores.sort(key=lambda row: (-row[1], -row[2]))
        line1 = &#34;â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”&#34;
        line2 = f&#39;â”‚ {&#34;Rank&#34;:^4} â”‚ {&#34;Names&#34;:^20} â”‚ &#39;
        line2 += f&#39;{&#34;Streak&#34;:^6} â”‚ {&#34;Points&#34;:^6} â”‚&#39;
        line3 = &#34;â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤&#34;
        end = &#34;â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜&#34;
        header = self._set_menu_header(f&#39;HIGH-SCORE TOP[{size}]&#39;, len(line1))
        center = []
        top = scores[0:size]
        for i in range(len(top)):
            name = scores[i][0]
            streak = scores[i][1]
            points = scores[i][2]
            row = f&#39;â”‚ {i+1:^4} â”‚ {name:^20} â”‚ {streak:^6} â”‚ {points:&gt;6} â”‚&#39;
            if i != len(top) - 1:
                row += f&#39;\nâ”‚ {&#34;&#34;:^4} â”‚ {&#34;&#34;:^20} â”‚ {&#34;&#34;:^6} â”‚ {&#34;&#34;:&gt;6} â”‚&#39;
            center.append(row)
        highscore = &#34;\n&#34;.join([header, line1, line2, line3] + center + [end])
        print(highscore)

    def display_message_and_continues(self, msg: str):
        &#34;&#34;&#34;
        Display message and waits for any key to be pressed.

        Args:
            msg (str): The message to display to the user.
        &#34;&#34;&#34;
        input(f&#39;{msg}&#39;)

    def insert_line_breaks(self, numb=1):
        &#34;&#34;&#34;
        Insert one or more line breaks into the console output.

        Description:
        This method inserts a specified number of line breaks
        into the console output.

        Args:
        - numb (int): An optional parameter which determines the number
                      of line breaks to insert into the console output.
                      Defaults to 1.
        &#34;&#34;&#34;
        [print() for _ in range(numb)]

    def print_to_display(self, msg: str):
        &#34;&#34;&#34;

        Print a message to the console.

        Description:
        This method takes a message string as input and prints it to the
        console.

        Args:
         - msg (str): The message to be printed.

        &#34;&#34;&#34;
        print(msg)

    def display_paused_game_message(self, code: str) -&gt; str:
        &#34;&#34;&#34;
        Display a message to the console and prompt for input.

        Description:
        This method displays a message to the console along with a code,
        and prompts the user to input any key to continue.

        Args:
        - code (str): The code for the paused game session.

        &#34;&#34;&#34;
        msg = &#39;\nYour game session has been saved under the CodeName:\n\n&#39;
        msg += &#39;       â”Œâ”€â”€â”€â”€â”€â”€â”\n&#39;
        msg += f&#39;       â”‚ {code} â”‚\n&#39;
        msg += &#39;       â””â”€â”€â”€â”€â”€â”€â”˜&#39;
        msg += &#39;\n\nUse this code (case sensitive) to resume your game.&#39;
        msg += &#39;\n\nSee you soon for another game of PIG!!\n&#39;
        msg += &#39;\nPress any key to go back to Start Up menu! &#39;
        return msg

    def cpu_question_answer_animation(self, msg1: str, msg2: str):
        &#34;&#34;&#34;
        Print animation to console.

        Description:
        This method takes two message strings as input and prints the first,
        message with a delay of 1.5 seconds,
        and then prints the second message with a delay of 0.5 seconds.

        Args:
        - msg1 (str): The first message to be printed.
        - msg2 (str): The second message to be printed.
        &#34;&#34;&#34;
        print(msg1, end=&#39; &#39;)
        time.sleep(1.5)
        print(msg2)
        time.sleep(0.5)

    def _shrink_name(self, name: str, max_len: int) -&gt; str:
        return name if len(name) &lt;= max_len else name[0:max_len - 3] + &#39;...&#39;

    def _get_rolls_points(self, points: int):
        line1 = &#34;&#34;
        line2 = &#34;  â”Œâ”€â”€â”€â”€â”€â”&#34;
        line3 = f&#39;{&#34;= â”‚&#34;} {points:&gt;3} â”‚&#39;
        line4 = &#34;  â””â”€â”€â”€â”€â”€â”˜&#34;
        line5 = &#34;&#34;
        return (line1, line2, line3, line4, line5)

    def _get_menu_layout(self, title: str, opt: list, legend) -&gt; str:
        leg1 = legend[0]
        leg2 = legend[1]
        line1 = &#34;â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”&#34;
        line2 = f&#39;â”‚ {leg1:^6} â”‚ {leg2:^20}{&#34; â”‚&#34;}&#39;
        line3 = &#34;â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤&#34;
        end = &#34;â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜&#34;
        center = []
        for i in range(len(opt)):
            row = f&#39;â”‚ {opt[i][0]:^6} â”‚ {opt[i][1]:&lt;20}{&#34; â”‚&#34;}&#39;
            if i != len(opt) - 1:
                row += f&#39;\nâ”‚ {&#34;&#34;:^6} â”‚ {&#34;&#34;:^20}{&#34; â”‚&#34;}&#39;
            center.append(row)
        start = [line1, line2, line3]
        header = self._set_menu_header(title, len(line1))
        menu = &#34;\n&#34;.join([header] + start + center + [end])
        return menu

    def _set_menu_header(self, title: str, width=40) -&gt; str:
        header = f&#34; {title} &#34;.center(width, &#34;~&#34;)
        return f&#39;\n{header}&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gui.GUI"><code class="flex name class">
<span>class <span class="ident">GUI</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class controls how the data is display to user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GUI:
    &#34;&#34;&#34;This class controls how the data is display to user.&#34;&#34;&#34;

    def clear_terminal(self):
        &#34;&#34;&#34;
        Clear the terminal window.

        Description:
            This method clears the contents of the terminal using the &#39;clear&#39;
            command from the os module. It is used to provide a clean slate for
            displaying new information to the user.

        &#34;&#34;&#34;
        os.system(&#39;clear&#39;)

    def display_info(self, text: str, title: str, width=40):
        &#34;&#34;&#34;
        Display information to the user.

        Description:
            This method displays the provided text and title to the user,
            formatted with a header created by the _set_menu_header() method.
            The width of the header can be customized using the width argument.
            The text is printed to the console using the print() function.

        Args:
            text (str): The text to display to the user.
            title (str): The title of the information being displayed.
            width (int, optional): The width of the header. Default is 40.
        &#34;&#34;&#34;
        header = self._set_menu_header(title, width)
        info = &#34;&#34;.join([header, text])
        print(info)

    def get_simple_answer_from_user(self, ask: str,
                                    title: str, width=40) -&gt; str:
        &#34;&#34;&#34;
        Get a simple user input.

        Description:
            This method displays a question to the user, along with a
            formatted title header created by the _set_menu_header() method.
            The user&#39;s response is read from the console using the input()
            function and returned as a string.

        Args:
            ask (str): The question to ask the user.
            title (str): The title of the input being requested.
            width (int, optional): The width of the header. Default is 40.

        Returns:
            str: The user&#39;s input as a string.
        &#34;&#34;&#34;
        header = self._set_menu_header(title, width)
        ask_input = &#34;\n&#34;.join([header, ask])
        return input(ask_input)

    def get_simple_answer_from_cpu(self, ask: str,
                                   title: str, width=40) -&gt; str:
        &#34;&#34;&#34;
        Get a simple response from the CPU.

        Description:
            This method displays a question to the CPU player, along with a
            formatted title header created by the _set_menu_header() method.
            The CPU&#39;s response is returned as a string.

        Args:
            ask (str): The question to ask the CPU.
            title (str): The title of the response being requested.
            width (int, optional): The width of the header. Default is 40.

        Returns:
            str: The CPU&#39;s response as a string.
        &#34;&#34;&#34;
        header = self._set_menu_header(title, width)
        ask_input = &#34;\n&#34;.join([header, ask])
        return ask_input

    def display_hand_results(self, numbers: list, points: int):
        &#34;&#34;&#34;
        Display the results of a dice roll.

        Description:
            This method takes a list of roll results and their point value,
            and formats them for display in a graphical representation of the
            dice faces. The resulting display is printed to the terminal.

        Args:
            numbers (list): A list of integers representing the face values
                            of the dice rolled.
            points (int): The total point value of the roll.

        &#34;&#34;&#34;
        faces = []
        for numb in numbers:
            faces.append(DICE_FACES[numb])

        faces_and_points = faces + [self._get_rolls_points(points)]

        faces_rows = []
        for idx in range(DIE_HEIGHT):
            row_cells = []
            for face in faces_and_points:
                row_cells.append(face[idx])
            row_line = DIE_SEP.join(row_cells)
            faces_rows.append(row_line)
        display = &#34;\n&#34;.join(faces_rows)
        print(display)

    def display_hand_results_split(self, numbers: list,
                                   points: int, split=4):
        &#34;&#34;&#34;
        Display the results of a hand of dice, split into chunks.

        Description:
        This method takes a list of integers representing the dice rolls,
        a total number of points, and an optional split parameter which
        determines how many dice should be displayed on each line.
        The method splits the dice rolls into chunks of size `split`,
        then displays the results of each chunk separately.
        The results of each chunk are displayed using the `DICE_FACES`
        constant, with a row of points displayed underneath the dice faces.

        Args:
        - numbers (list): A list of integers representing the dice rolls.
        - points (int): The total number of points for the hand.
        - split (int): An optional parameter which determines how many dice
          should be displayed on each line. Defaults to 4.
        &#34;&#34;&#34;
        chunk = [numbers[i:split+i] for i in range(0, len(numbers), split)]
        rows = []
        for int_list in chunk:
            faces = []
            for numb in int_list:
                faces.append(DICE_FACES[numb])
            if int_list == chunk[-1]:
                fap = faces + [self._get_rolls_points(points)]
            else:
                fap = faces + []
            faces_rows = []
            for idx in range(DIE_HEIGHT):
                row_cells = []
                for face in fap:
                    row_cells.append(face[idx])
                row_line = DIE_SEP.join(row_cells)
                faces_rows.append(row_line)
            display = &#34;\n&#34;.join(faces_rows)
            rows.append(display)
        lines = &#34;\n&#34;.join(rows)
        print(lines)

    def display_scoreboard(self, n1: str, s1: int,
                           n2: str, s2: int, hand: str):
        &#34;&#34;&#34;
        Display a scoreboard with two players&#39; names, scores, and current hand.

        Description:
        This method takes in the names and scores of two players,
        as well as the name of the player whose turn it is.
        It then generates a graphical scoreboard displaying the two players&#39;
        names and scores, along with an indication of whose turn it is.
        The scoreboard is printed to the console.

        Args:
            n1 (str): The name of player 1.
            s1 (int): The score of player 1.
            n2 (str): The name of player 2.
            s2 (int): The score of player 2.
            hand (str): The name of the player whose turn it is.

        &#34;&#34;&#34;
        c = [&#39;ğŸŸ©&#39;, &#39;ğŸŸ¥&#39;]
        if hand == n2:
            c.reverse()
        n1 = self._shrink_name(n1, 13)
        n2 = self._shrink_name(n2, 13)
        line1 = &#34;â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”&#34;
        line2 = f&#39;â”‚ {c[0]} â”‚ {n1:&lt;13}    {s1:&gt;3} â”‚ â”‚ &#39;
        line2 += f&#39;{c[1]} â”‚ {n2:&lt;13}    {s2:&gt;3}{&#34; â”‚&#34;}&#39;
        line3 = &#34;â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜&#34;
        scoreboard = &#34;\n&#34;.join([line1, line2, line3])
        print(scoreboard)

    def get_text_to_shown_menu(self, title: str,
                               question: str, options: list,
                               legend=[&#39;Option&#39;, &#39;Actions&#39;]) -&gt; str:
        &#34;&#34;&#34;
        Get user input from a shown menu.

        Description:
        This method displays a menu with the given title and options,
        and prompts the user with the given question to select an option.
        The method returns the user&#39;s input as a string.

        Args:
        - title (str): The title to display at the top of the menu.
        - question (str): The prompt to display to the user.
        - options (list): A list of strings representing the menu options.
        - legend (list): An optional list of strings that specify the column
          headings of the menu. Defaults to [&#39;Option&#39;, &#39;Actions&#39;].

        Returns:
        - input (str): The user&#39;s input as a string.
        &#34;&#34;&#34;
        menu = self._get_menu_layout(title, options, legend)
        menu += f&#34;\n{question}&#34;

        return menu

    def display_highscore(self, scores: list, size: int):
        &#34;&#34;&#34;
        Display high scores in a tabular format.

        Description:
        This method takes a list of high scores,
        displays them in a tabular format,
        with columns for rank, name, streak, and points.
        The table is sorted by the streak,
        and points columns in descending order.
        The number of scores displayedis determined by the `size` parameter.

        Args:
        - scores (list): A list of tuples containing the player name,
                         streak, and points.
        - size (int): The number of high scores to display.

        &#34;&#34;&#34;
        scores.sort(key=lambda row: (-row[1], -row[2]))
        line1 = &#34;â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”&#34;
        line2 = f&#39;â”‚ {&#34;Rank&#34;:^4} â”‚ {&#34;Names&#34;:^20} â”‚ &#39;
        line2 += f&#39;{&#34;Streak&#34;:^6} â”‚ {&#34;Points&#34;:^6} â”‚&#39;
        line3 = &#34;â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤&#34;
        end = &#34;â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜&#34;
        header = self._set_menu_header(f&#39;HIGH-SCORE TOP[{size}]&#39;, len(line1))
        center = []
        top = scores[0:size]
        for i in range(len(top)):
            name = scores[i][0]
            streak = scores[i][1]
            points = scores[i][2]
            row = f&#39;â”‚ {i+1:^4} â”‚ {name:^20} â”‚ {streak:^6} â”‚ {points:&gt;6} â”‚&#39;
            if i != len(top) - 1:
                row += f&#39;\nâ”‚ {&#34;&#34;:^4} â”‚ {&#34;&#34;:^20} â”‚ {&#34;&#34;:^6} â”‚ {&#34;&#34;:&gt;6} â”‚&#39;
            center.append(row)
        highscore = &#34;\n&#34;.join([header, line1, line2, line3] + center + [end])
        print(highscore)

    def display_message_and_continues(self, msg: str):
        &#34;&#34;&#34;
        Display message and waits for any key to be pressed.

        Args:
            msg (str): The message to display to the user.
        &#34;&#34;&#34;
        input(f&#39;{msg}&#39;)

    def insert_line_breaks(self, numb=1):
        &#34;&#34;&#34;
        Insert one or more line breaks into the console output.

        Description:
        This method inserts a specified number of line breaks
        into the console output.

        Args:
        - numb (int): An optional parameter which determines the number
                      of line breaks to insert into the console output.
                      Defaults to 1.
        &#34;&#34;&#34;
        [print() for _ in range(numb)]

    def print_to_display(self, msg: str):
        &#34;&#34;&#34;

        Print a message to the console.

        Description:
        This method takes a message string as input and prints it to the
        console.

        Args:
         - msg (str): The message to be printed.

        &#34;&#34;&#34;
        print(msg)

    def display_paused_game_message(self, code: str) -&gt; str:
        &#34;&#34;&#34;
        Display a message to the console and prompt for input.

        Description:
        This method displays a message to the console along with a code,
        and prompts the user to input any key to continue.

        Args:
        - code (str): The code for the paused game session.

        &#34;&#34;&#34;
        msg = &#39;\nYour game session has been saved under the CodeName:\n\n&#39;
        msg += &#39;       â”Œâ”€â”€â”€â”€â”€â”€â”\n&#39;
        msg += f&#39;       â”‚ {code} â”‚\n&#39;
        msg += &#39;       â””â”€â”€â”€â”€â”€â”€â”˜&#39;
        msg += &#39;\n\nUse this code (case sensitive) to resume your game.&#39;
        msg += &#39;\n\nSee you soon for another game of PIG!!\n&#39;
        msg += &#39;\nPress any key to go back to Start Up menu! &#39;
        return msg

    def cpu_question_answer_animation(self, msg1: str, msg2: str):
        &#34;&#34;&#34;
        Print animation to console.

        Description:
        This method takes two message strings as input and prints the first,
        message with a delay of 1.5 seconds,
        and then prints the second message with a delay of 0.5 seconds.

        Args:
        - msg1 (str): The first message to be printed.
        - msg2 (str): The second message to be printed.
        &#34;&#34;&#34;
        print(msg1, end=&#39; &#39;)
        time.sleep(1.5)
        print(msg2)
        time.sleep(0.5)

    def _shrink_name(self, name: str, max_len: int) -&gt; str:
        return name if len(name) &lt;= max_len else name[0:max_len - 3] + &#39;...&#39;

    def _get_rolls_points(self, points: int):
        line1 = &#34;&#34;
        line2 = &#34;  â”Œâ”€â”€â”€â”€â”€â”&#34;
        line3 = f&#39;{&#34;= â”‚&#34;} {points:&gt;3} â”‚&#39;
        line4 = &#34;  â””â”€â”€â”€â”€â”€â”˜&#34;
        line5 = &#34;&#34;
        return (line1, line2, line3, line4, line5)

    def _get_menu_layout(self, title: str, opt: list, legend) -&gt; str:
        leg1 = legend[0]
        leg2 = legend[1]
        line1 = &#34;â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”&#34;
        line2 = f&#39;â”‚ {leg1:^6} â”‚ {leg2:^20}{&#34; â”‚&#34;}&#39;
        line3 = &#34;â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤&#34;
        end = &#34;â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜&#34;
        center = []
        for i in range(len(opt)):
            row = f&#39;â”‚ {opt[i][0]:^6} â”‚ {opt[i][1]:&lt;20}{&#34; â”‚&#34;}&#39;
            if i != len(opt) - 1:
                row += f&#39;\nâ”‚ {&#34;&#34;:^6} â”‚ {&#34;&#34;:^20}{&#34; â”‚&#34;}&#39;
            center.append(row)
        start = [line1, line2, line3]
        header = self._set_menu_header(title, len(line1))
        menu = &#34;\n&#34;.join([header] + start + center + [end])
        return menu

    def _set_menu_header(self, title: str, width=40) -&gt; str:
        header = f&#34; {title} &#34;.center(width, &#34;~&#34;)
        return f&#39;\n{header}&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gui.GUI.clear_terminal"><code class="name flex">
<span>def <span class="ident">clear_terminal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear the terminal window.</p>
<h2 id="description">Description</h2>
<p>This method clears the contents of the terminal using the 'clear'
command from the os module. It is used to provide a clean slate for
displaying new information to the user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_terminal(self):
    &#34;&#34;&#34;
    Clear the terminal window.

    Description:
        This method clears the contents of the terminal using the &#39;clear&#39;
        command from the os module. It is used to provide a clean slate for
        displaying new information to the user.

    &#34;&#34;&#34;
    os.system(&#39;clear&#39;)</code></pre>
</details>
</dd>
<dt id="gui.GUI.cpu_question_answer_animation"><code class="name flex">
<span>def <span class="ident">cpu_question_answer_animation</span></span>(<span>self, msg1:Â str, msg2:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Print animation to console.</p>
<p>Description:
This method takes two message strings as input and prints the first,
message with a delay of 1.5 seconds,
and then prints the second message with a delay of 0.5 seconds.</p>
<p>Args:
- msg1 (str): The first message to be printed.
- msg2 (str): The second message to be printed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cpu_question_answer_animation(self, msg1: str, msg2: str):
    &#34;&#34;&#34;
    Print animation to console.

    Description:
    This method takes two message strings as input and prints the first,
    message with a delay of 1.5 seconds,
    and then prints the second message with a delay of 0.5 seconds.

    Args:
    - msg1 (str): The first message to be printed.
    - msg2 (str): The second message to be printed.
    &#34;&#34;&#34;
    print(msg1, end=&#39; &#39;)
    time.sleep(1.5)
    print(msg2)
    time.sleep(0.5)</code></pre>
</details>
</dd>
<dt id="gui.GUI.display_hand_results"><code class="name flex">
<span>def <span class="ident">display_hand_results</span></span>(<span>self, numbers:Â list, points:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the results of a dice roll.</p>
<h2 id="description">Description</h2>
<p>This method takes a list of roll results and their point value,
and formats them for display in a graphical representation of the
dice faces. The resulting display is printed to the terminal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>numbers</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of integers representing the face values
of the dice rolled.</dd>
<dt><strong><code>points</code></strong> :&ensp;<code>int</code></dt>
<dd>The total point value of the roll.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_hand_results(self, numbers: list, points: int):
    &#34;&#34;&#34;
    Display the results of a dice roll.

    Description:
        This method takes a list of roll results and their point value,
        and formats them for display in a graphical representation of the
        dice faces. The resulting display is printed to the terminal.

    Args:
        numbers (list): A list of integers representing the face values
                        of the dice rolled.
        points (int): The total point value of the roll.

    &#34;&#34;&#34;
    faces = []
    for numb in numbers:
        faces.append(DICE_FACES[numb])

    faces_and_points = faces + [self._get_rolls_points(points)]

    faces_rows = []
    for idx in range(DIE_HEIGHT):
        row_cells = []
        for face in faces_and_points:
            row_cells.append(face[idx])
        row_line = DIE_SEP.join(row_cells)
        faces_rows.append(row_line)
    display = &#34;\n&#34;.join(faces_rows)
    print(display)</code></pre>
</details>
</dd>
<dt id="gui.GUI.display_hand_results_split"><code class="name flex">
<span>def <span class="ident">display_hand_results_split</span></span>(<span>self, numbers:Â list, points:Â int, split=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the results of a hand of dice, split into chunks.</p>
<p>Description:
This method takes a list of integers representing the dice rolls,
a total number of points, and an optional split parameter which
determines how many dice should be displayed on each line.
The method splits the dice rolls into chunks of size <code>split</code>,
then displays the results of each chunk separately.
The results of each chunk are displayed using the <code>DICE_FACES</code>
constant, with a row of points displayed underneath the dice faces.</p>
<p>Args:
- numbers (list): A list of integers representing the dice rolls.
- points (int): The total number of points for the hand.
- split (int): An optional parameter which determines how many dice
should be displayed on each line. Defaults to 4.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_hand_results_split(self, numbers: list,
                               points: int, split=4):
    &#34;&#34;&#34;
    Display the results of a hand of dice, split into chunks.

    Description:
    This method takes a list of integers representing the dice rolls,
    a total number of points, and an optional split parameter which
    determines how many dice should be displayed on each line.
    The method splits the dice rolls into chunks of size `split`,
    then displays the results of each chunk separately.
    The results of each chunk are displayed using the `DICE_FACES`
    constant, with a row of points displayed underneath the dice faces.

    Args:
    - numbers (list): A list of integers representing the dice rolls.
    - points (int): The total number of points for the hand.
    - split (int): An optional parameter which determines how many dice
      should be displayed on each line. Defaults to 4.
    &#34;&#34;&#34;
    chunk = [numbers[i:split+i] for i in range(0, len(numbers), split)]
    rows = []
    for int_list in chunk:
        faces = []
        for numb in int_list:
            faces.append(DICE_FACES[numb])
        if int_list == chunk[-1]:
            fap = faces + [self._get_rolls_points(points)]
        else:
            fap = faces + []
        faces_rows = []
        for idx in range(DIE_HEIGHT):
            row_cells = []
            for face in fap:
                row_cells.append(face[idx])
            row_line = DIE_SEP.join(row_cells)
            faces_rows.append(row_line)
        display = &#34;\n&#34;.join(faces_rows)
        rows.append(display)
    lines = &#34;\n&#34;.join(rows)
    print(lines)</code></pre>
</details>
</dd>
<dt id="gui.GUI.display_highscore"><code class="name flex">
<span>def <span class="ident">display_highscore</span></span>(<span>self, scores:Â list, size:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>Display high scores in a tabular format.</p>
<p>Description:
This method takes a list of high scores,
displays them in a tabular format,
with columns for rank, name, streak, and points.
The table is sorted by the streak,
and points columns in descending order.
The number of scores displayedis determined by the <code>size</code> parameter.</p>
<p>Args:
- scores (list): A list of tuples containing the player name,
streak, and points.
- size (int): The number of high scores to display.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_highscore(self, scores: list, size: int):
    &#34;&#34;&#34;
    Display high scores in a tabular format.

    Description:
    This method takes a list of high scores,
    displays them in a tabular format,
    with columns for rank, name, streak, and points.
    The table is sorted by the streak,
    and points columns in descending order.
    The number of scores displayedis determined by the `size` parameter.

    Args:
    - scores (list): A list of tuples containing the player name,
                     streak, and points.
    - size (int): The number of high scores to display.

    &#34;&#34;&#34;
    scores.sort(key=lambda row: (-row[1], -row[2]))
    line1 = &#34;â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”&#34;
    line2 = f&#39;â”‚ {&#34;Rank&#34;:^4} â”‚ {&#34;Names&#34;:^20} â”‚ &#39;
    line2 += f&#39;{&#34;Streak&#34;:^6} â”‚ {&#34;Points&#34;:^6} â”‚&#39;
    line3 = &#34;â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤&#34;
    end = &#34;â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜&#34;
    header = self._set_menu_header(f&#39;HIGH-SCORE TOP[{size}]&#39;, len(line1))
    center = []
    top = scores[0:size]
    for i in range(len(top)):
        name = scores[i][0]
        streak = scores[i][1]
        points = scores[i][2]
        row = f&#39;â”‚ {i+1:^4} â”‚ {name:^20} â”‚ {streak:^6} â”‚ {points:&gt;6} â”‚&#39;
        if i != len(top) - 1:
            row += f&#39;\nâ”‚ {&#34;&#34;:^4} â”‚ {&#34;&#34;:^20} â”‚ {&#34;&#34;:^6} â”‚ {&#34;&#34;:&gt;6} â”‚&#39;
        center.append(row)
    highscore = &#34;\n&#34;.join([header, line1, line2, line3] + center + [end])
    print(highscore)</code></pre>
</details>
</dd>
<dt id="gui.GUI.display_info"><code class="name flex">
<span>def <span class="ident">display_info</span></span>(<span>self, text:Â str, title:Â str, width=40)</span>
</code></dt>
<dd>
<div class="desc"><p>Display information to the user.</p>
<h2 id="description">Description</h2>
<p>This method displays the provided text and title to the user,
formatted with a header created by the _set_menu_header() method.
The width of the header can be customized using the width argument.
The text is printed to the console using the print() function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to display to the user.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title of the information being displayed.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The width of the header. Default is 40.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_info(self, text: str, title: str, width=40):
    &#34;&#34;&#34;
    Display information to the user.

    Description:
        This method displays the provided text and title to the user,
        formatted with a header created by the _set_menu_header() method.
        The width of the header can be customized using the width argument.
        The text is printed to the console using the print() function.

    Args:
        text (str): The text to display to the user.
        title (str): The title of the information being displayed.
        width (int, optional): The width of the header. Default is 40.
    &#34;&#34;&#34;
    header = self._set_menu_header(title, width)
    info = &#34;&#34;.join([header, text])
    print(info)</code></pre>
</details>
</dd>
<dt id="gui.GUI.display_message_and_continues"><code class="name flex">
<span>def <span class="ident">display_message_and_continues</span></span>(<span>self, msg:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Display message and waits for any key to be pressed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>str</code></dt>
<dd>The message to display to the user.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_message_and_continues(self, msg: str):
    &#34;&#34;&#34;
    Display message and waits for any key to be pressed.

    Args:
        msg (str): The message to display to the user.
    &#34;&#34;&#34;
    input(f&#39;{msg}&#39;)</code></pre>
</details>
</dd>
<dt id="gui.GUI.display_paused_game_message"><code class="name flex">
<span>def <span class="ident">display_paused_game_message</span></span>(<span>self, code:Â str) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Display a message to the console and prompt for input.</p>
<p>Description:
This method displays a message to the console along with a code,
and prompts the user to input any key to continue.</p>
<p>Args:
- code (str): The code for the paused game session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_paused_game_message(self, code: str) -&gt; str:
    &#34;&#34;&#34;
    Display a message to the console and prompt for input.

    Description:
    This method displays a message to the console along with a code,
    and prompts the user to input any key to continue.

    Args:
    - code (str): The code for the paused game session.

    &#34;&#34;&#34;
    msg = &#39;\nYour game session has been saved under the CodeName:\n\n&#39;
    msg += &#39;       â”Œâ”€â”€â”€â”€â”€â”€â”\n&#39;
    msg += f&#39;       â”‚ {code} â”‚\n&#39;
    msg += &#39;       â””â”€â”€â”€â”€â”€â”€â”˜&#39;
    msg += &#39;\n\nUse this code (case sensitive) to resume your game.&#39;
    msg += &#39;\n\nSee you soon for another game of PIG!!\n&#39;
    msg += &#39;\nPress any key to go back to Start Up menu! &#39;
    return msg</code></pre>
</details>
</dd>
<dt id="gui.GUI.display_scoreboard"><code class="name flex">
<span>def <span class="ident">display_scoreboard</span></span>(<span>self, n1:Â str, s1:Â int, n2:Â str, s2:Â int, hand:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Display a scoreboard with two players' names, scores, and current hand.</p>
<p>Description:
This method takes in the names and scores of two players,
as well as the name of the player whose turn it is.
It then generates a graphical scoreboard displaying the two players'
names and scores, along with an indication of whose turn it is.
The scoreboard is printed to the console.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n1</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of player 1.</dd>
<dt><strong><code>s1</code></strong> :&ensp;<code>int</code></dt>
<dd>The score of player 1.</dd>
<dt><strong><code>n2</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of player 2.</dd>
<dt><strong><code>s2</code></strong> :&ensp;<code>int</code></dt>
<dd>The score of player 2.</dd>
<dt><strong><code>hand</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the player whose turn it is.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_scoreboard(self, n1: str, s1: int,
                       n2: str, s2: int, hand: str):
    &#34;&#34;&#34;
    Display a scoreboard with two players&#39; names, scores, and current hand.

    Description:
    This method takes in the names and scores of two players,
    as well as the name of the player whose turn it is.
    It then generates a graphical scoreboard displaying the two players&#39;
    names and scores, along with an indication of whose turn it is.
    The scoreboard is printed to the console.

    Args:
        n1 (str): The name of player 1.
        s1 (int): The score of player 1.
        n2 (str): The name of player 2.
        s2 (int): The score of player 2.
        hand (str): The name of the player whose turn it is.

    &#34;&#34;&#34;
    c = [&#39;ğŸŸ©&#39;, &#39;ğŸŸ¥&#39;]
    if hand == n2:
        c.reverse()
    n1 = self._shrink_name(n1, 13)
    n2 = self._shrink_name(n2, 13)
    line1 = &#34;â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”&#34;
    line2 = f&#39;â”‚ {c[0]} â”‚ {n1:&lt;13}    {s1:&gt;3} â”‚ â”‚ &#39;
    line2 += f&#39;{c[1]} â”‚ {n2:&lt;13}    {s2:&gt;3}{&#34; â”‚&#34;}&#39;
    line3 = &#34;â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜&#34;
    scoreboard = &#34;\n&#34;.join([line1, line2, line3])
    print(scoreboard)</code></pre>
</details>
</dd>
<dt id="gui.GUI.get_simple_answer_from_cpu"><code class="name flex">
<span>def <span class="ident">get_simple_answer_from_cpu</span></span>(<span>self, ask:Â str, title:Â str, width=40) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Get a simple response from the CPU.</p>
<h2 id="description">Description</h2>
<p>This method displays a question to the CPU player, along with a
formatted title header created by the _set_menu_header() method.
The CPU's response is returned as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ask</code></strong> :&ensp;<code>str</code></dt>
<dd>The question to ask the CPU.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title of the response being requested.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The width of the header. Default is 40.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The CPU's response as a string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_simple_answer_from_cpu(self, ask: str,
                               title: str, width=40) -&gt; str:
    &#34;&#34;&#34;
    Get a simple response from the CPU.

    Description:
        This method displays a question to the CPU player, along with a
        formatted title header created by the _set_menu_header() method.
        The CPU&#39;s response is returned as a string.

    Args:
        ask (str): The question to ask the CPU.
        title (str): The title of the response being requested.
        width (int, optional): The width of the header. Default is 40.

    Returns:
        str: The CPU&#39;s response as a string.
    &#34;&#34;&#34;
    header = self._set_menu_header(title, width)
    ask_input = &#34;\n&#34;.join([header, ask])
    return ask_input</code></pre>
</details>
</dd>
<dt id="gui.GUI.get_simple_answer_from_user"><code class="name flex">
<span>def <span class="ident">get_simple_answer_from_user</span></span>(<span>self, ask:Â str, title:Â str, width=40) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Get a simple user input.</p>
<h2 id="description">Description</h2>
<p>This method displays a question to the user, along with a
formatted title header created by the _set_menu_header() method.
The user's response is read from the console using the input()
function and returned as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ask</code></strong> :&ensp;<code>str</code></dt>
<dd>The question to ask the user.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title of the input being requested.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The width of the header. Default is 40.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The user's input as a string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_simple_answer_from_user(self, ask: str,
                                title: str, width=40) -&gt; str:
    &#34;&#34;&#34;
    Get a simple user input.

    Description:
        This method displays a question to the user, along with a
        formatted title header created by the _set_menu_header() method.
        The user&#39;s response is read from the console using the input()
        function and returned as a string.

    Args:
        ask (str): The question to ask the user.
        title (str): The title of the input being requested.
        width (int, optional): The width of the header. Default is 40.

    Returns:
        str: The user&#39;s input as a string.
    &#34;&#34;&#34;
    header = self._set_menu_header(title, width)
    ask_input = &#34;\n&#34;.join([header, ask])
    return input(ask_input)</code></pre>
</details>
</dd>
<dt id="gui.GUI.get_text_to_shown_menu"><code class="name flex">
<span>def <span class="ident">get_text_to_shown_menu</span></span>(<span>self, title:Â str, question:Â str, options:Â list, legend=['Option', 'Actions']) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Get user input from a shown menu.</p>
<p>Description:
This method displays a menu with the given title and options,
and prompts the user with the given question to select an option.
The method returns the user's input as a string.</p>
<p>Args:
- title (str): The title to display at the top of the menu.
- question (str): The prompt to display to the user.
- options (list): A list of strings representing the menu options.
- legend (list): An optional list of strings that specify the column
headings of the menu. Defaults to ['Option', 'Actions'].</p>
<p>Returns:
- input (str): The user's input as a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_text_to_shown_menu(self, title: str,
                           question: str, options: list,
                           legend=[&#39;Option&#39;, &#39;Actions&#39;]) -&gt; str:
    &#34;&#34;&#34;
    Get user input from a shown menu.

    Description:
    This method displays a menu with the given title and options,
    and prompts the user with the given question to select an option.
    The method returns the user&#39;s input as a string.

    Args:
    - title (str): The title to display at the top of the menu.
    - question (str): The prompt to display to the user.
    - options (list): A list of strings representing the menu options.
    - legend (list): An optional list of strings that specify the column
      headings of the menu. Defaults to [&#39;Option&#39;, &#39;Actions&#39;].

    Returns:
    - input (str): The user&#39;s input as a string.
    &#34;&#34;&#34;
    menu = self._get_menu_layout(title, options, legend)
    menu += f&#34;\n{question}&#34;

    return menu</code></pre>
</details>
</dd>
<dt id="gui.GUI.insert_line_breaks"><code class="name flex">
<span>def <span class="ident">insert_line_breaks</span></span>(<span>self, numb=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert one or more line breaks into the console output.</p>
<p>Description:
This method inserts a specified number of line breaks
into the console output.</p>
<p>Args:
- numb (int): An optional parameter which determines the number
of line breaks to insert into the console output.
Defaults to 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_line_breaks(self, numb=1):
    &#34;&#34;&#34;
    Insert one or more line breaks into the console output.

    Description:
    This method inserts a specified number of line breaks
    into the console output.

    Args:
    - numb (int): An optional parameter which determines the number
                  of line breaks to insert into the console output.
                  Defaults to 1.
    &#34;&#34;&#34;
    [print() for _ in range(numb)]</code></pre>
</details>
</dd>
<dt id="gui.GUI.print_to_display"><code class="name flex">
<span>def <span class="ident">print_to_display</span></span>(<span>self, msg:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Print a message to the console.</p>
<p>Description:
This method takes a message string as input and prints it to the
console.</p>
<p>Args:
- msg (str): The message to be printed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_to_display(self, msg: str):
    &#34;&#34;&#34;

    Print a message to the console.

    Description:
    This method takes a message string as input and prints it to the
    console.

    Args:
     - msg (str): The message to be printed.

    &#34;&#34;&#34;
    print(msg)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gui.GUI" href="#gui.GUI">GUI</a></code></h4>
<ul class="">
<li><code><a title="gui.GUI.clear_terminal" href="#gui.GUI.clear_terminal">clear_terminal</a></code></li>
<li><code><a title="gui.GUI.cpu_question_answer_animation" href="#gui.GUI.cpu_question_answer_animation">cpu_question_answer_animation</a></code></li>
<li><code><a title="gui.GUI.display_hand_results" href="#gui.GUI.display_hand_results">display_hand_results</a></code></li>
<li><code><a title="gui.GUI.display_hand_results_split" href="#gui.GUI.display_hand_results_split">display_hand_results_split</a></code></li>
<li><code><a title="gui.GUI.display_highscore" href="#gui.GUI.display_highscore">display_highscore</a></code></li>
<li><code><a title="gui.GUI.display_info" href="#gui.GUI.display_info">display_info</a></code></li>
<li><code><a title="gui.GUI.display_message_and_continues" href="#gui.GUI.display_message_and_continues">display_message_and_continues</a></code></li>
<li><code><a title="gui.GUI.display_paused_game_message" href="#gui.GUI.display_paused_game_message">display_paused_game_message</a></code></li>
<li><code><a title="gui.GUI.display_scoreboard" href="#gui.GUI.display_scoreboard">display_scoreboard</a></code></li>
<li><code><a title="gui.GUI.get_simple_answer_from_cpu" href="#gui.GUI.get_simple_answer_from_cpu">get_simple_answer_from_cpu</a></code></li>
<li><code><a title="gui.GUI.get_simple_answer_from_user" href="#gui.GUI.get_simple_answer_from_user">get_simple_answer_from_user</a></code></li>
<li><code><a title="gui.GUI.get_text_to_shown_menu" href="#gui.GUI.get_text_to_shown_menu">get_text_to_shown_menu</a></code></li>
<li><code><a title="gui.GUI.insert_line_breaks" href="#gui.GUI.insert_line_breaks">insert_line_breaks</a></code></li>
<li><code><a title="gui.GUI.print_to_display" href="#gui.GUI.print_to_display">print_to_display</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>